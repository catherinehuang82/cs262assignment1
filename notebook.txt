Log of ideas/updates!

Feb 8, 2023
=============================================================================
- Got a basic connection/messaging service working!
    - Beween one server and one client
- Questions
    - How to know which ports are available to connect to?
    - What kind of text wildcards do we need to support? (Wrt #2 on the spec)
        - Are prefixes/suffixes/substrings enough? Or do we need to support more complicated stuff like regexp?
        - One group is using tries, but these only support prefix/suffix
    - How to exit from chat — is newline “\n” fine?
    - When can the user list accounts? Should the user be able to trigger this feature anytime using a certain message string? Or does the user only need to be able to do this before they connect to a client/server?
- Things to add/fix
    - Currently assumes server and client must message back and forth:
      one side waits until the other responds to be able to send a message.
      We should allow people to message without waiting.
    - Need to keep track of multiple users with usernames and make threads
      for each one. Be able to list accounts. Specify which user you want to
      send a message to when sending messages.
    - Implement ability to delete accounts.
    - Implement queueing messages for users that are not currently logged in.
    - Implement error for nonexistent users.


Feb 11/12, 2023
=============================================================================
Progress:
- implemented forking so that multiple clients can talk to the server
- tested three clients talking to the server at the same time
- created original_client.cc and original_server.cc to "save" our baseline client/server implementations (without forking, only supports one client connected to the server at once)

Bugs:
- the server cannot use the same port twice in the same session. In other words, it cannot hold a complete conversation with port 6000 and then use port 6000 again. 
    - if it does, we get a "Error binding socket to local address" error message, which prints out when the std::bind(serverSd, (struct sockaddr*) &servAddr, sizeof(servAddr)); function call status is < 0.
    - however, if we have the server run on port 6001, there is no bug, and we get the desired "Waiting for a client to connect..." Functionality
    - maybe this could help? https://stackoverflow.com/questions/548879/releasing-bound-ports-on-process-exit
- issues with the server closing off ports
    - when the server is down or operating on a different port (e.g. 6001) but the client tries to connect to a port that the server previously opened (e.g. 6000), trouble arises: the client gets "Connected to the server! \n >"
    - but the server cannot talk to the client
    - the client has no choice but to ^C out of the program, but when it does that, the server enters into an infinite loop, where the message sent to the server is "Awaiting client response..."
    - something like this: ">Awaiting client response..." "Client:" ">Awaiting client response..." "Client:" etc.
    - so I'm thinking we need to properly close server ports when the server shuts down <- there is probably an issue here
    - this could be tied to the bug above where the server somehow cannot use a port that it previously used but is now done using

Missing features:
- server cannot choose which client recipient to send message to, so it just cycles between each client when sending messages
- we do not ask clients for their usernames
- we do not track which clients (and usernames) are associated with which socket IDs

Things I've tried:
- I started work on tracking client info on server.hh (which defines a struct to store client info). We want to threads to read from and write to this struct safely, so we need a mutex and condition variable.

TODOs:
- resolve the bugs mentioned above
- keep working on the client info implementation

Misc:
- Karly's IP: 10.250.109.84
- Catherine's IP: 10.250.69.72
- Shell command to get your IP: ipconfig getifaddr en0

Useful links:
- "Client-Server chat in C++ using sockets": https://simpledevcode.wordpress.com/2016/06/16/client-server-chat-in-c-using-sockets/
- "Design a concurrent server for handling multiple clients using fork()" GeeksForGeeks article: https://www.geeksforgeeks.org/design-a-concurrent-server-for-handling-multiple-clients-using-fork/
- (probably useful down the line) "Handling multiple clients on server with multithreading using Socket Programming in C/C++": https://www.geeksforgeeks.org/handling-multiple-clients-on-server-with-multithreading-using-socket-programming-in-c-cpp/
- (not yet used but could be relevant) "Socket Programming in C/C++: Handling multiple clients on server without multi threading": https://www.geeksforgeeks.org/socket-programming-in-cc-handling-multiple-clients-on-server-without-multi-threading/

Feb 13, 2023 morning
=============================================================================
Progress:
- changed the server so that it still runs (and can accept future clients) even when all current clients have exited
- properly updating the number of actively connected clients (i.e., decrementing client count when a client exits)
- typing "exit" into the server does not necessarily shut down the server, though...but Ctrl+C handles this okay
- updated server socket settings through the line setsockopt(serverSd, SOL_SOCKET, SO_REUSEADDR, (char*)&iSetOption, sizeof(iSetOption));
    - this allows for reuse of local addresses during bind()
    - so that we can use the same port multiple times in the same session

Bugs:
- "Error binding socket to local address" for port 6000 (could be a firewall issue)
- occasionally, we still get an "Error binding socket to local address" error when trying to reuse some ports (e.g. port 3005 raised this issue)

Questions:
- Could we possibly use the c++ select() linux command? This command allows us to monitor multiple file descriptors, waiting until one of the fd's become active. In our case, we can notify the client socket when server chooses to send a message to that particular client.
    - The next best alternative to select() is to create a new thread for every new client connected to the server, but this is difficult to debug...
- How do we reuse the same server port multiple times in the same session? setsockopt(serverSd, SOL_SOCKET, SO_REUSEADDR, ..., ...); doesn't always work



Feb 13, 2023 afternoon
=============================================================================
Progress:
- put the client/server fork implementation in server_fork.cc and client_fork.cc
- started new implementation using c++ select() linux command in server.cc and client.cc, using https://www.geeksforgeeks.org/socket-programming-in-cc-handling-multiple-clients-on-server-without-multi-threading/

Feb 13, 2023 evening
=============================================================================
Progress:
- we learned that in this client/server model, clients are supposed to send EACH OTHER messages. The server is just a middle man that relays client messages to their desired recipients. To that end, I adjusted implementation so that client 0 can send messages to itself without server intervention (i.e., it can talk to itself)
    - I intended to write a program that has all messages (from all clients) sent to client 0

Bugs:
- two clients were able to connect, but the second client's message wasn't going anywhere (not to the server, nor to client 0)
- I suspect it's a while loop issue, maybe get rid of line 161 on server2.cc? Either way, I'll look at https://www.geeksforgeeks.org/socket-programming-in-cc-handling-multiple-clients-on-server-without-multi-threading/ in more detail

Feb 14, 2023 morning
=============================================================================
Progress:
- server (server2.cc) now supports having each client talk to themselves
- server no longer runs into an infinite loop after client quits, as long as client quits properly ("exit" rather than Ctrl+C)
    - we can probably modify implementation so that the proper way for client to quit is Ctrl+C

Next steps:
- have client be able to specify which recipient (client) to send to, and have server correctly send message to the correct client